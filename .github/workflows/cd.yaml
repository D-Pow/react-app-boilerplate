# Using multiple workflow .yaml files
# https://stackoverflow.com/questions/64009546/how-to-run-multiple-github-actions-workflows-from-sub-directories


# TODO
# Preventing concurrent workflows (e.g. multiple merges to master at once)
# https://github.blog/changelog/2021-04-19-github-actions-limit-workflow-run-or-job-concurrency/
# From: https://github.community/t/how-to-limit-concurrent-workflow-runs/16844/
#
# Further split sub-directories' actions/workflows for more granular control.
#   - https://stackoverflow.com/questions/64009546/how-to-run-multiple-github-actions-workflows-from-sub-directories


# If we decide to use Docker - Using local Dockerfile in pipeline:
#   steps:
#   - name: Check out code
#     uses: actions/checkout@v2
#   - name: Build docker images
#     run: docker build -t local < .devcontainer/Dockerfile # .devcontainer is the local path
#   - name: Run tests
#     run: docker run -it -v $PWD:/srv -w/srv local make test
#  OR
#   - name: Build docker images
#     run: docker-compose build
#   - name: Run tests
#     run: docker-compose run test
# Ref: https://stackoverflow.com/questions/61154750/use-local-dockerfile-in-a-github-action


name: CD


on:
  workflow_dispatch:
  # Publish your release in GitHub and have your pipeline react to deploy the package
  release:
    types: [ published ]
  # Run the pipeline on merge to `master` and do the release/deploy then.
  # pull_request:
  #   types: [ closed ]
  #   branches: [ master ]
  #
  # Run on CI completion (the `if:` in the `deploy` job below would need updating accordingly)
  # workflow_run:
  #   workflows: [ 'CI' ]
  #   types: [ completed ]
  #   branches: [ master ]
  workflow_run:
    workflows: [ 'CI' ]
    types: [ completed ]
    branches: [ master ]


defaults:
  run:
    shell: bash
    working-directory: ./


env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  gitUserName: ${{ github.actor }}
  gitUserEmail: ${{ github.actor }}@users.noreply.github.com
  # nodeVersion: 16
  # increment-version: 'TODO'


jobs:
  cd-client:
    runs-on: ubuntu-latest
    # Only run on merge to master, but not on PR to master since PRs are just drafts, not officially prod-ready code.
    #
    # See:
    #   - https://github.community/t/depend-on-another-workflow/16311/3
    #   - https://stackoverflow.com/questions/66205887/only-run-github-actions-step-if-not-a-pull-request/66206183#66206183
    if: ${{ github.event_name != 'pull_request' && (github.event.pull_request.merged || github.ref == 'refs/heads/master') }}
    steps:
      - name: CD:Client - Checkout repository branch
        uses: actions/checkout@v2

      - name: CD:Client - Set NodeJS version
        uses: actions/setup-node@v2
        with:
          node-version: ${{ env.nodeVersion }}

      - name: CD:Client - Build - Download CI cache
        uses: actions/cache/restore@v3
        with:
          path: |
            node_modules
            dist
            package.json
            package-lock.json
          key: ${{ env.CLIENT_CACHE_ID }}
        continue-on-error: false

      - if: ${{ failure() }}
        name: Client CD - Build and generate CI artifacts
        uses: ./.github/workflows/actions/client/build
        env:
          GITHUB_TOKEN: ${{ env.GITHUB_TOKEN }}
          gitUserName: ${{ env.gitUserName }}
          gitUserEmail: ${{ env.gitUserEmail }}
          nodeVersion: ${{ env.nodeVersion }}
        with:
          incrementVersion: ${{ env.increment-version }}


  cd-deploy:
    runs-on: ubuntu-latest
    needs: [ cd-client ]
    permissions:
      pages: write      # Grant write permissions to deploy to the `gh-pages` (or whatever is specified in "Settings") branch
      id-token: write   # to verify the deployment originates from an appropriate source
      deployments: write
      packages: write
      actions: write
      contents: write
    steps:
      - name: CD:Client - Checkout repository branch
        uses: actions/checkout@v2

      - name: CD:Client - Set NodeJS version
        uses: actions/setup-node@v2
        with:
          node-version: ${{ env.nodeVersion }}

      - name: CD:Client - Deploy - Download CI cache
        uses: actions/cache/restore@v3
        with:
          path: |
            node_modules
            dist
            package.json
            package-lock.json
          key: ${{ env.CLIENT_CACHE_ID }}
        continue-on-error: false

      - name: Client CD - Check cache name cd
        id: cache-name-cd
        run: |
          echo "${{ steps.client-init-cache.outputs }}"
          echo "$CLIENT_CACHE_ID -- ${{ env.CLIENT_CACHE_ID }}"

      # - if: ${{ env.increment-version == true }}
      #   name: Client CD Deploy - Upgrade app version
      #   # Not necessarily required since `npm version` returns the version string (with "v" in it), but for reference:
      #   #   - Normal: npm version patch; git commit --amend -m "Patch to v$(jq -r '.version' package.json)"
      #   #   - Without git commit or tag: newAppVersion=$(npm version --no-git-tag-version patch); git commit -am "Patch to ${newAppVersion}"
      #   # Note that the git branch is defined here (unlike in composite actions) so we can run normal `git` CLI commands
      #   run: |
      #     git pull
      #
      #     git config --global user.name ${{ env.gitUserName }}
      #     git config --global user.email ${{ env.gitUserEmail }}
      #
      #     # New version is actually incremented and set within the client/build/ action
      #     # so we only need to push the change to the git repo here
      #     newAppVersion="$(jq -r '.version' package.json)"
      #
      #     git commit -am "Patch to ${newAppVersion}"
      #     git push
      #
      # # Ignore pre-/post- npm scripts via `npm run --ignore-scripts <my-script>`.
      # # This could be useful for, e.g. scripts like `deploy` since `predeploy` (`npm run build`)
      # # was already run in CI.
      # #
      # # Set `user.name` and `user.email` for ~/.gitconfig inline via the `--user` flag for `gh-pages`:
      # #   npm run --ignore-scripts deploy -- --user "${{ env.gitUserName }} <${{ env.gitUserEmail }}>"
      # - name: CD - Deploy application to gh-pages
      #   # We need to either cache the build output after the version is incremented, or re-run
      #   # `npm run build` so the version is injected into the code where needed.
      #   run: |
      #     git pull
      #     git checkout gh-pages
      #
      #     ( for path in $(ls --ignore=dist --ignore=.git); do rm -rf "$path"; done; )
      #
      #     cp -R dist/* .
      #
      #     ( for path in dist/*; do git add "$(echo "$path" | sed -E 's/dist/./')"; done; )
      #
      #     rm -rf dist
