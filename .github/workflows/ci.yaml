name: CI


# TODO Looks like workflows ARE reusable now: https://docs.github.com/en/actions/using-workflows/reusing-workflows#creating-a-reusable-workflow
# Controls when the action will run.
on:
  # Allows you to run this workflow manually from the web GUI "Actions" tab
  workflow_dispatch:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]


# Specify defaults for all jobs' `run` blocks.
# See:
#   https://github.community/t/use-working-directory-for-entire-job/16747/9
#   https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_iddefaultsrun
#   https://github.community/t/github-actions-configure-defaults-option/18438/3
defaults:
  run:
    shell: bash
    working-directory: ./


# Set GitHub user info for ease of use of `gh` CLI commands.
#
# See:
#   - https://docs.npmjs.com/cli/v9/commands/npm-run-script#ignore-scripts
#   - https://stackoverflow.com/questions/59471962/how-does-npm-behave-differently-with-ignore-scripts-set-to-true
#   - https://github.com/tschaub/gh-pages#optionsuser
#   - https://github.com/actions/checkout/issues/13
env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  gitUserName: ${{ github.actor }}
  gitUserEmail: ${{ github.actor }}@users.noreply.github.com
  nodeVersion: 16
  client-cache-name: client-cache
  # increment-version: 'TODO'


# A workflow run is made up of one or more jobs that can run sequentially or in parallel
# Workflows require at least one job that has no dependencies.
# However, we can still use the `uses` block for "reusable workflows"
#
# See:
#   - Reusable workflows `uses`: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iduses
jobs:
  ci-verify-build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Specify defaults for all steps that override top-level `defaults`
    # defaults:
    #   run:
    #     # Specify directory in which to run all subsequent steps/commands
    #     #
    #     # e.g. If using a monolith with `./client/` and `./server/` directories, then set:
    #     # `working-directory: ./client`
    #     working-directory: ./

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it.
      # Note: Files don't carry over between separate jobs so merge the git-checkout/env-setup
      # logic in with the actual job logic.
      - name: Checkout repository branch
        uses: actions/checkout@v2

      - name: Set NodeJS version
        uses: actions/setup-node@v2
        with:
          node-version: ${{ env.nodeVersion }}

      # Downloads previous runs' cache of content like node_modules/ for faster re-runs
      - name: Client CI - Download cache
        uses: actions/cache/restore@v3
        with:
          path: |
            node_modules
            dist
            package.json
            package-lock.json
          key: ${{ env.client-cache-name }}-${{ runner.os }}-${{ hashFiles('./src/**', './test/**', './tests/**', './config/**', './mocks/**') }}

      - name: Client CI - Check cache name before
        id: cache-name-before
        run: |
          echo "${{ steps.client-init-cache.outputs }}"
          echo "$CLIENT_CACHE_ID -- ${{ env.CLIENT_CACHE_ID }}"

      - name: Client CI - Run all
        # Import reusable GitHub Action logic via `uses`
        uses: ./.github/workflows/actions/client
        # Set env vars for all nested actions
        # See:
        #   - https://github.com/orgs/community/discussions/27088
        #   - https://stackoverflow.com/questions/70098241/using-secrets-in-composite-actions-github/70111134#70111134
        #   - https://stackoverflow.com/questions/63663436/what-is-difference-between-with-and-env
        env:
          GITHUB_TOKEN: ${{ env.GITHUB_TOKEN }}
          gitUserName: ${{ env.gitUserName }}
          gitUserEmail: ${{ env.gitUserEmail }}
          nodeVersion: ${{ env.nodeVersion }}
        with:
          incrementVersion: ${{ env.increment-version }}

      - name: Client CI - Check cache name after
        id: cache-name-after
        run: |
          echo "${{ steps.client-init-cache.outputs }}"
          echo "$CLIENT_CACHE_ID -- ${{ env.CLIENT_CACHE_ID }}"

  ci-post-verify-build-check:
    runs-on: ubuntu-latest
    needs: [ ci-verify-build ]
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it.
      # Note: Files don't carry over between separate jobs so merge the git-checkout/env-setup
      # logic in with the actual job logic.
      - name: Checkout repository branch
        uses: actions/checkout@v2

      - name: Set NodeJS version
        uses: actions/setup-node@v2
        with:
          node-version: ${{ env.nodeVersion }}

      - name: Client CI - Check cache name separate job
        id: cache-name-separate-job
        run: |
          echo "${{ steps.client-init-cache.outputs }}"
          echo "$CLIENT_CACHE_ID -- ${{ env.CLIENT_CACHE_ID }}"
